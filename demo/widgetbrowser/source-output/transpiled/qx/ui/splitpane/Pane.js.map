{
  "version": 3,
  "sources": [
    "Pane.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "ui",
    "core",
    "Widget",
    "construct",
    "orientation",
    "__children",
    "setOrientation",
    "initOrientation",
    "__blocker",
    "addListener",
    "_onPointerDown",
    "_onPointerUp",
    "_onPointerMove",
    "_onPointerOut",
    "properties",
    "appearance",
    "refine",
    "init",
    "offset",
    "check",
    "apply",
    "members",
    "__splitterOffset",
    "__activeDragSession",
    "__lastPointerX",
    "__lastPointerY",
    "__isHorizontal",
    "__beginSize",
    "__endSize",
    "_createChildControlImpl",
    "id",
    "hash",
    "control",
    "splitpane",
    "Slider",
    "exclude",
    "_add",
    "type",
    "Splitter",
    "__onSplitterMove",
    "e",
    "__setBlockerPosition",
    "getData",
    "__createBlocker",
    "Blocker",
    "getContentElement",
    "add",
    "splitter",
    "getChildControl",
    "splitterWidth",
    "getWidth",
    "addListenerOnce",
    "bounds",
    "height",
    "width",
    "hide",
    "show",
    "getBlocker",
    "_applyOrientation",
    "value",
    "old",
    "slider",
    "oldLayout",
    "_getLayout",
    "dispose",
    "newLayout",
    "VLayout",
    "HLayout",
    "_setLayout",
    "removeState",
    "addState",
    "queue",
    "Manager",
    "flush",
    "_applyOffset",
    "getOffset",
    "splitterBounds",
    "getBounds",
    "splitterElem",
    "getDomElement",
    "left",
    "isNaN",
    "bom",
    "element",
    "Location",
    "getPosition",
    "setWidth",
    "setLeft",
    "top",
    "setHeight",
    "setTop",
    "widget",
    "flex",
    "push",
    "remove",
    "_remove",
    "lang",
    "Array",
    "getChildren",
    "isLeftPressed",
    "splitterLocation",
    "getContentLocation",
    "paneLocation",
    "getDocumentLeft",
    "getDocumentTop",
    "setUserBounds",
    "setZIndex",
    "getZIndex",
    "capture",
    "stop",
    "_setLastPointerPosition",
    "__computeSizes",
    "pos",
    "setDomLeft",
    "setStyle",
    "setDomTop",
    "_finalizeSizes",
    "releaseCapture",
    "beginSize",
    "endSize",
    "children",
    "_getChildren",
    "firstWidget",
    "secondWidget",
    "firstFlexValue",
    "getLayoutProperties",
    "secondFlexValue",
    "setLayoutProperties",
    "min",
    "size",
    "max",
    "pointer",
    "beginHint",
    "getSizeHint",
    "endHint",
    "allocatedSize",
    "_isActiveDragSession",
    "x",
    "y",
    "destruct",
    "Pane"
  ],
  "mappings": "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",
  "file": "Pane.js",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Jonathan Weiß (jonathan_rass)\n\n************************************************************************ */\n\n/**\n * A split panes divides an area into two panes. The ratio between the two\n * panes is configurable by the user using the splitter.\n *\n * @childControl slider {qx.ui.splitpane.Slider} shown during resizing the splitpane\n * @childControl splitter {qx.ui.splitpane.Splitter} splitter to resize the splitpane\n */\nqx.Class.define(\"qx.ui.splitpane.Pane\",\n{\n  extend : qx.ui.core.Widget,\n\n\n\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  /**\n   * Creates a new instance of a SplitPane. It allows the user to dynamically\n   * resize the areas dropping the border between.\n   *\n   * @param orientation {String} The orientation of the split pane control.\n   * Allowed values are \"horizontal\" (default) and \"vertical\".\n   */\n  construct : function(orientation)\n  {\n    this.base(arguments);\n\n    this.__children = [];\n\n    // Initialize orientation\n    if (orientation) {\n      this.setOrientation(orientation);\n    } else {\n      this.initOrientation();\n    }\n\n    // add all pointer listener to the blocker\n    this.__blocker.addListener(\"pointerdown\", this._onPointerDown, this);\n    this.__blocker.addListener(\"pointerup\", this._onPointerUp, this);\n    this.__blocker.addListener(\"pointermove\", this._onPointerMove, this);\n    this.__blocker.addListener(\"pointerout\", this._onPointerOut, this);\n    this.__blocker.addListener(\"losecapture\", this._onPointerUp, this);\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     PROPERTIES\n  *****************************************************************************\n  */\n\n  properties :\n  {\n    // overridden\n    appearance :\n    {\n      refine : true,\n      init : \"splitpane\"\n    },\n\n    /**\n     * Distance between pointer and splitter when the cursor should change\n     * and enable resizing.\n     */\n    offset :\n    {\n      check : \"Integer\",\n      init : 6,\n      apply : \"_applyOffset\"\n    },\n\n    /**\n     * The orientation of the splitpane control.\n     */\n    orientation :\n    {\n      init  : \"horizontal\",\n      check : [ \"horizontal\", \"vertical\" ],\n      apply : \"_applyOrientation\"\n    }\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n\n    __splitterOffset : null,\n    __activeDragSession : false,\n    __lastPointerX : null,\n    __lastPointerY : null,\n    __isHorizontal : null,\n    __beginSize : null,\n    __endSize : null,\n    __children : null,\n    __blocker : null,\n\n\n    // overridden\n    _createChildControlImpl : function(id, hash)\n    {\n      var control;\n\n      switch(id)\n      {\n        // Create and add slider\n        case \"slider\":\n          control = new qx.ui.splitpane.Slider(this);\n          control.exclude();\n          this._add(control, {type : id});\n          break;\n\n        // Create splitter\n        case \"splitter\":\n          control = new qx.ui.splitpane.Splitter(this);\n          this._add(control, {type : id});\n          control.addListener(\"move\", this.__onSplitterMove, this);\n          break;\n      }\n\n      return control || this.base(arguments, id);\n    },\n\n\n    /**\n     * Move handler for the splitter which takes care of the external\n     * triggered resize of children.\n     *\n     * @param e {qx.event.type.Data} The data even of move.\n     */\n    __onSplitterMove : function(e) {\n      this.__setBlockerPosition(e.getData());\n    },\n\n\n    /**\n     * Creates a blocker for the splitter which takes all bouse events and\n     * also handles the offset and cursor.\n     *\n     * @param orientation {String} The orientation of the pane.\n     */\n    __createBlocker : function(orientation) {\n      this.__blocker = new qx.ui.splitpane.Blocker(orientation);\n      this.getContentElement().add(this.__blocker);\n\n      var splitter = this.getChildControl(\"splitter\");\n      var splitterWidth = splitter.getWidth();\n      if (!splitterWidth) {\n        splitter.addListenerOnce(\"appear\", function() {\n          this.__setBlockerPosition();\n        }, this);\n      }\n\n      // resize listener to remove the blocker in case the splitter\n      // is removed.\n      splitter.addListener(\"resize\", function(e) {\n        var bounds = e.getData();\n        if (bounds.height == 0 || bounds.width == 0) {\n          this.__blocker.hide();\n        } else {\n          this.__blocker.show();\n        }\n      }, this);\n    },\n\n\n    /**\n     * Returns the blocker used over the splitter. this could be used for\n     * adding event listeners like tap or dbltap.\n     *\n     * @return {qx.ui.splitpane.Blocker} The used blocker element.\n     *\n     * @internal\n     */\n    getBlocker : function() {\n      return this.__blocker;\n    },\n\n\n\n    /*\n    ---------------------------------------------------------------------------\n      PROPERTY APPLY METHODS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Apply routine for the orientation property.\n     *\n     * Sets the pane's layout to vertical or horizontal split layout.\n     *\n     * @param value {String} The new value of the orientation property\n     * @param old {String} The old value of the orientation property\n     */\n    _applyOrientation : function(value, old)\n    {\n      var slider = this.getChildControl(\"slider\");\n      var splitter = this.getChildControl(\"splitter\");\n\n      // Store boolean flag for faster access\n      this.__isHorizontal = value === \"horizontal\";\n\n      if (!this.__blocker) {\n        this.__createBlocker(value);\n      }\n\n      // update the blocker\n      this.__blocker.setOrientation(value);\n\n      // Dispose old layout\n      var oldLayout = this._getLayout();\n      if (oldLayout) {\n        oldLayout.dispose();\n      }\n\n      // Create new layout\n      var newLayout = value === \"vertical\" ?\n        new qx.ui.splitpane.VLayout : new qx.ui.splitpane.HLayout;\n      this._setLayout(newLayout);\n\n      // Update states for splitter and slider\n      splitter.removeState(old);\n      splitter.addState(value);\n      splitter.getChildControl(\"knob\").removeState(old);\n      splitter.getChildControl(\"knob\").addState(value);\n      slider.removeState(old);\n      slider.addState(value);\n\n      // flush (needs to be done for the blocker update) and update the blocker\n      qx.ui.core.queue.Manager.flush();\n      this.__setBlockerPosition();\n    },\n\n\n    // property apply\n    _applyOffset : function(value, old) {\n      this.__setBlockerPosition();\n    },\n\n\n    /**\n     * Helper for setting the blocker to the right position, which depends on\n     * the offset, orientation and the current position of the splitter.\n     *\n     * @param bounds {Map?null} If the bounds of the splitter are known,\n     *   they can be added.\n     */\n    __setBlockerPosition : function(bounds) {\n      var splitter = this.getChildControl(\"splitter\");\n      var offset = this.getOffset();\n      var splitterBounds = splitter.getBounds();\n      var splitterElem = splitter.getContentElement().getDomElement();\n\n      // do nothing if the splitter is not ready\n      if (!splitterElem) {\n        return;\n      }\n\n      // recalculate the dimensions of the blocker\n      if (this.__isHorizontal) {\n        // get the width either of the given bounds or of the read bounds\n        var width = null;\n        if (bounds) {\n          width = bounds.width;\n        } else if (splitterBounds) {\n          width = splitterBounds.width;\n        }\n        var left = bounds && bounds.left;\n\n        if (width) {\n          if (isNaN(left)) {\n            left = qx.bom.element.Location.getPosition(splitterElem).left;\n          }\n          this.__blocker.setWidth(offset, width);\n          this.__blocker.setLeft(offset, left);\n        }\n\n      // vertical case\n      } else {\n        // get the height either of the given bounds or of the read bounds\n        var height = null;\n        if (bounds) {\n          height = bounds.height;\n        } else if (splitterBounds) {\n          height = splitterBounds.height;\n        }\n        var top =  bounds && bounds.top;\n\n        if (height) {\n          if (isNaN(top)) {\n            top = qx.bom.element.Location.getPosition(splitterElem).top;\n          }\n          this.__blocker.setHeight(offset, height);\n          this.__blocker.setTop(offset, top);\n        }\n      }\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n      PUBLIC METHODS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Adds a widget to the pane.\n     *\n     * Sets the pane's layout to vertical or horizontal split layout. Depending on the\n     * pane's layout the first widget will be the left or top widget, the second one\n     * the bottom or right widget. Adding more than two widgets will overwrite the\n     * existing ones.\n     *\n     * @param widget {qx.ui.core.Widget} The widget to be inserted into pane.\n     * @param flex {Number} The (optional) layout property for the widget's flex value.\n     */\n    add : function(widget, flex)\n    {\n      if (flex == null) {\n        this._add(widget);\n      } else {\n        this._add(widget, {flex : flex});\n      }\n      this.__children.push(widget);\n    },\n\n\n    /**\n     * Removes the given widget from the pane.\n     *\n     * @param widget {qx.ui.core.Widget} The widget to be removed.\n     */\n    remove : function(widget)\n    {\n      this._remove(widget);\n      qx.lang.Array.remove(this.__children, widget);\n    },\n\n\n    /**\n     * Returns an array containing the pane's content.\n     *\n     * @return {qx.ui.core.Widget[]} The pane's child widgets\n     */\n    getChildren : function() {\n      return this.__children;\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n      POINTER LISTENERS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Handler for pointerdown event.\n     *\n     * Shows slider widget and starts drag session if pointer is near/on splitter widget.\n     *\n     * @param e {qx.event.type.Pointer} pointerdown event\n     */\n    _onPointerDown : function(e)\n    {\n      // Only proceed if left pointer button is pressed and the splitter is active\n      if (!e.isLeftPressed()) {\n        return;\n      }\n\n      var splitter = this.getChildControl(\"splitter\");\n\n      // Store offset between pointer event coordinates and splitter\n      var splitterLocation = splitter.getContentLocation();\n      var paneLocation = this.getContentLocation();\n      this.__splitterOffset = this.__isHorizontal ?\n        e.getDocumentLeft() - splitterLocation.left + paneLocation.left :\n        e.getDocumentTop() - splitterLocation.top + paneLocation.top ;\n\n      // Synchronize slider to splitter size and show it\n      var slider = this.getChildControl(\"slider\");\n      var splitterBounds = splitter.getBounds();\n      slider.setUserBounds(\n        splitterBounds.left, splitterBounds.top,\n        splitterBounds.width, splitterBounds.height\n      );\n\n      slider.setZIndex(splitter.getZIndex() + 1);\n      slider.show();\n\n      // Enable session\n      this.__activeDragSession = true;\n      this.__blocker.capture();\n\n      e.stop();\n    },\n\n\n    /**\n     * Handler for pointermove event.\n     *\n     * @param e {qx.event.type.Pointer} pointermove event\n     */\n    _onPointerMove : function(e)\n    {\n      this._setLastPointerPosition(e.getDocumentLeft(), e.getDocumentTop());\n\n      // Check if slider is already being dragged\n      if (this.__activeDragSession)\n      {\n        // Compute new children sizes\n        this.__computeSizes();\n\n        // Update slider position\n        var slider = this.getChildControl(\"slider\");\n        var pos = this.__beginSize;\n\n        if(this.__isHorizontal) {\n          slider.setDomLeft(pos);\n          this.__blocker.setStyle(\"left\", (pos - this.getOffset()) + \"px\");\n        } else {\n          slider.setDomTop(pos);\n          this.__blocker.setStyle(\"top\", (pos - this.getOffset()) + \"px\");\n        }\n\n        e.stop();\n      }\n    },\n\n\n    /**\n     * Handler for pointerout event\n     *\n     * @param e {qx.event.type.Pointer} pointerout event\n     */\n    _onPointerOut : function(e)\n    {\n      this._setLastPointerPosition(e.getDocumentLeft(), e.getDocumentTop());\n    },\n\n\n    /**\n     * Handler for pointerup event\n     *\n     * Sets widget sizes if dragging session has been active.\n     *\n     * @param e {qx.event.type.Pointer} pointerup event\n     */\n    _onPointerUp : function(e)\n    {\n      if (!this.__activeDragSession) {\n        return;\n      }\n\n      // Set sizes to both widgets\n      this._finalizeSizes();\n\n      // Hide the slider\n      var slider = this.getChildControl(\"slider\");\n      slider.exclude();\n\n      // Cleanup\n      this.__activeDragSession = false;\n      this.releaseCapture();\n\n      e.stop();\n    },\n\n\n    /*\n    ---------------------------------------------------------------------------\n      INTERVAL HANDLING\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Updates widgets' sizes based on the slider position.\n     */\n    _finalizeSizes : function()\n    {\n      var beginSize = this.__beginSize;\n      var endSize = this.__endSize;\n\n      if (beginSize == null) {\n        return;\n      }\n\n      var children = this._getChildren();\n      var firstWidget = children[2];\n      var secondWidget = children[3];\n\n      // Read widgets' flex values\n      var firstFlexValue = firstWidget.getLayoutProperties().flex;\n      var secondFlexValue = secondWidget.getLayoutProperties().flex;\n\n      // Both widgets have flex values\n      if((firstFlexValue != 0) && (secondFlexValue != 0))\n      {\n        firstWidget.setLayoutProperties({ flex : beginSize });\n        secondWidget.setLayoutProperties({ flex : endSize });\n      }\n\n      // Update both sizes\n      else\n      {\n        // Set widths to static widgets\n        if (this.__isHorizontal)\n        {\n          firstWidget.setWidth(beginSize);\n          secondWidget.setWidth(endSize);\n        }\n        else\n        {\n          firstWidget.setHeight(beginSize);\n          secondWidget.setHeight(endSize);\n        }\n      }\n    },\n\n\n    /**\n     * Computes widgets' sizes based on the pointer coordinate.\n     */\n    __computeSizes : function()\n    {\n      if (this.__isHorizontal) {\n        var min=\"minWidth\", size=\"width\", max=\"maxWidth\", pointer=this.__lastPointerX;\n      } else {\n        var min=\"minHeight\", size=\"height\", max=\"maxHeight\", pointer=this.__lastPointerY;\n      }\n\n      var children = this._getChildren();\n      var beginHint = children[2].getSizeHint();\n      var endHint = children[3].getSizeHint();\n\n      // Area given to both widgets\n      var allocatedSize = children[2].getBounds()[size] + children[3].getBounds()[size];\n\n      // Calculate widget sizes\n      var beginSize = pointer - this.__splitterOffset;\n      var endSize = allocatedSize - beginSize;\n\n      // Respect minimum limits\n      if (beginSize < beginHint[min])\n      {\n        endSize -= beginHint[min] - beginSize;\n        beginSize = beginHint[min];\n      }\n      else if (endSize < endHint[min])\n      {\n        beginSize -= endHint[min] - endSize;\n        endSize = endHint[min];\n      }\n\n      // Respect maximum limits\n      if (beginSize > beginHint[max])\n      {\n        endSize += beginSize - beginHint[max];\n        beginSize = beginHint[max];\n      }\n      else if (endSize > endHint[max])\n      {\n        beginSize += endSize - endHint[max];\n        endSize = endHint[max];\n      }\n\n      // Store sizes\n      this.__beginSize = beginSize;\n      this.__endSize = endSize;\n    },\n\n\n    /**\n     * Determines whether this is an active drag session\n     *\n     * @return {Boolean} True if active drag session, otherwise false.\n     */\n    _isActiveDragSession : function() {\n      return this.__activeDragSession;\n    },\n\n\n    /**\n     * Sets the last pointer position.\n     *\n     * @param x {Integer} the x position of the pointer.\n     * @param y {Integer} the y position of the pointer.\n     */\n     _setLastPointerPosition : function(x, y)\n     {\n       this.__lastPointerX = x;\n       this.__lastPointerY = y;\n     }\n  },\n\n\n  destruct : function() {\n    this.__children = null;\n  }\n});\n"
  ]
}